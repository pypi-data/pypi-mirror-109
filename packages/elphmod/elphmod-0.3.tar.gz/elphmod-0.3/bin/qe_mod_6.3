#!/usr/bin/env python3

# Copyright (C) 2021 elphmod Developers
# This program is free software under the terms of the GNU GPLv3 or later.

"""Usage: qe_mod /path/to/q-e/

ATTENTION: This script will modify QE sources files without backup!
Use QE's Git repository and verify or undo changes with "git diff"!
These changes are compatible with version "qe-6.3-backports" only!
"""

import sys

if len(sys.argv) > 1:
    QE = sys.argv[1]
else:
    raise SystemExit(__doc__.strip())

def modify(filename, *args):
    path = '/'.join((QE, filename))

    with open(path) as source:
        lines = source.readlines()

    def join(i, j=len(lines)):
        return ''.join(lines[i - 1:j])

    with open(path, 'w') as new:
        for arg in args:
            if type(arg) is tuple:
                new.write(join(*arg))
            else:
                new.write(arg.lstrip('\n'))

modify('LR_Modules/lrcom.f90', (1, 49), r'''
  LOGICAL  :: bare           ! if .TRUE. calculate fully bare phonons
  LOGICAL  :: cdfpt          ! if .TRUE. applies cDFPT
  INTEGER, ALLOCATABLE :: cdfpt_subspace(:, :, :, :)
''', (50,))

modify('LR_Modules/orthogonalize.f90', (1, 31), r'''
  USE klist,            ONLY : lgauss, degauss, ngauss, ltetra, wk, xk
  USE start_k,          ONLY : nk1, nk2, nk3
  USE cell_base,        ONLY : at
''', (33, 42), r'''
  USE control_lr,       ONLY : alpha_pv, nbnd_occ, cdfpt, cdfpt_subspace
''', (44, 55), r'''
  INTEGER :: ibnd, jbnd, nbnd_eff, n_start, n_end, kk1, kk2, kk3, kq1, kq2, kq3
''', (57, 59), r'''
  !
  kk1 = modulo(nint(nk1 * dot_product(at(:, 1), xk(:, ikk))), nk1) + 1
  kk2 = modulo(nint(nk2 * dot_product(at(:, 2), xk(:, ikk))), nk2) + 1
  kk3 = modulo(nint(nk3 * dot_product(at(:, 3), xk(:, ikk))), nk3) + 1
  !
  kq1 = modulo(nint(nk1 * dot_product(at(:, 1), xk(:, ikq))), nk1) + 1
  kq2 = modulo(nint(nk2 * dot_product(at(:, 2), xk(:, ikq))), nk2) + 1
  kq3 = modulo(nint(nk3 * dot_product(at(:, 3), xk(:, ikq))), nk3) + 1
''', (60, 70), r'''
  IF (ltetra .OR. lgauss .OR. cdfpt) THEN
''', (72, 92), r'''
              !
              IF (cdfpt) THEN
                 IF (any(cdfpt_subspace(:, kk1, kk2, kk3) == ibnd) .AND. &
                     any(cdfpt_subspace(:, kq1, kq2, kq3) == jbnd)) THEN
                    ps(jbnd, ibnd) = wg1 * ps(jbnd, ibnd)
                    CYCLE
                 ENDIF
              ENDIF
              !
''', (93, 112), r'''
        ELSEIF (cdfpt) THEN
           !
           DO jbnd = nbnd_occ(ikq) + 1, nbnd
              IF (all(cdfpt_subspace(:, kk1, kk2, kk3) /= ibnd) .OR. &
                  all(cdfpt_subspace(:, kq1, kq2, kq3) /= jbnd)) THEN
                 ps(jbnd, ibnd) = 0.0_DP
              ENDIF
           ENDDO
           CYCLE
           !
''', (113, 187), r'''
  IF (lgauss .OR. ltetra .OR. cdfpt) THEN
''', (189,))

modify('PHonon/PH/elph.f90', (1, 14), r'''
  LOGICAL :: elph, elph_mat, elph_simple, elph_epa, elph_defpot
''', (16,))

modify('PHonon/PH/phq_readin.f90', (1, 69), r'''
                            elph_defpot, &
''', (70, 73), r'''
  USE control_lr,    ONLY : lgamma, lrpa, bare, cdfpt, cdfpt_subspace
''', (75, 110), r'''
  CHARACTER(LEN=256) :: subspace
  !
''', (111, 123), r'''
                       lshift_q, bare, cdfpt, subspace
''', (125, 302), r'''
  bare = .false.
  cdfpt = .false.
  subspace = 'subspace.dat'
  !
''', (303, 338), r'''
  !
  CALL mp_bcast(bare, meta_ionode_id, world_comm)
  CALL mp_bcast(cdfpt, meta_ionode_id, world_comm)
  IF (cdfpt) CALL setup_subspace(cdfpt_subspace, subspace)
''', (339, 372), r'''
  elph_defpot = .false.
''', (373, 394), r'''
  CASE( 'defpot' )
     elph=.true.
     elph_mat=.false.
     elph_simple=.false.
     elph_epa=.false.
     elph_defpot=.true.
''', (395, 796), r'''
  IF (elph .AND. .NOT. (lgauss .OR. ltetra) &
      .AND. .NOT. (elph_yambo .OR. elph_defpot)) &
          CALL errore ('phq_readin', 'Electron-phonon only for metals', 1)
''', (799, 844), r'''
CONTAINS
  !
  SUBROUTINE setup_subspace(subspace, filename)
     INTEGER, ALLOCATABLE, INTENT(OUT) :: subspace(:, :, :, :)
     CHARACTER(LEN=256), INTENT(IN) :: filename
     !
     INTEGER, EXTERNAL :: find_free_unit
     INTEGER :: id, nk(3), bands, band, offset
     !
     id = find_free_unit()
     !
     IF (meta_ionode) THEN
        OPEN (id, file=filename, action='read', status='old')
        READ (id, *) nk, bands, offset
     ENDIF
     !
     CALL mp_bcast(nk, meta_ionode_id, world_comm)
     CALL mp_bcast(bands, meta_ionode_id, world_comm)
     !
     ALLOCATE(subspace(bands, nk(1), nk(2), nk(3)))
     !
     IF (meta_ionode) THEN
        DO band = 1, bands
           READ (id, *) subspace(band, :, :, :)
        ENDDO
        CLOSE (id)
        subspace(:, :, :, :) = subspace + offset
     ENDIF
     !
     CALL bcast_integer(subspace, size(subspace), meta_ionode_id, world_comm)
  END SUBROUTINE
''', (845,))

modify('PHonon/PH/do_phonon.f90', (1, 35), r'''
  USE el_phon,         ONLY : elph, elph_mat, elph_simple, elph_epa, elph_defpot
''', (37, 128), r'''
        ELSEIF (.NOT. elph_defpot) THEN
''', (130,))

modify('PHonon/PH/solve_linter.f90', (1, 73), r'''
  USE control_lr,   ONLY : alpha_pv, nbnd_occ, lgamma, bare
''', (75, 362), r'''
           IF (.NOT. bare) THEN
              call cgsolve_all (ch_psi_all, cg_psi, et(1,ikk), dvpsi, dpsi, &
                                h_diag, npwx, npwq, thresh, ik, lter, conv_root, &
                                anorm, nbnd_occ(ikk), npol )
           ENDIF
''', (366,))

modify('EPW/src/ephwann_shuffle.f90', (1, 358), r'''
  !
  IF (ionode) THEN
    OPEN (13, file='wigner.dat', action='write', status='replace', access='stream')
    WRITE (13) nrr_k, irvec_k, ndegen_k, wslen_k
    WRITE (13) nrr_q, irvec_q, ndegen_q, wslen_q
    WRITE (13) nrr_g, irvec_g, ndegen_g, wslen_g
    CLOSE (13)
  ENDIF
''', (359,))
