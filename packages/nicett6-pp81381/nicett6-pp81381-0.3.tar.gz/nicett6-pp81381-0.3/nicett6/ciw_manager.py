import asyncio
import logging
from nicett6.cover import TT6Cover
from nicett6.ttbus_device import TTBusDeviceAddress
from nicett6.ciw_helper import CIWHelper, ImageDef
from nicett6.connection import TT6Reader, TT6Writer, TT6Connection
from nicett6.decode import PctPosResponse


_LOGGER = logging.getLogger(__name__)


class CIWManager:

    POLLING_INTERVAL = 0.2

    def __init__(
        self,
        serial_port: str,
        screen_tt_addr: TTBusDeviceAddress,
        mask_tt_addr: TTBusDeviceAddress,
        screen_max_drop: float,
        mask_max_drop: float,
        image_def: ImageDef,
    ):
        self._serial_port = serial_port
        self._screen_tt_addr = screen_tt_addr
        self._mask_tt_addr = mask_tt_addr
        self.helper = CIWHelper(screen_max_drop, mask_max_drop, image_def)
        self._conn = None
        self._message_tracker_reader: TT6Reader = None
        self._writer: TT6Writer = None
        self.screen_tt6_cover: TT6Cover = None
        self.mask_tt6_cover: TT6Cover = None

    async def __aenter__(self):
        await self.open()
        return self

    async def __aexit__(self, exception_type, exception_value, traceback):
        self.close()

    async def open(self):
        self._conn = TT6Connection()
        await self._conn.open(self._serial_port)
        # NOTE: message_tracker_reader is created here rather than in message_tracker
        # to ensure that all messages from this moment on are captured
        # in particular: the initial position messages generated by _start()
        self._message_tracker_reader: TT6Reader = self._conn.add_reader()
        self._writer = self._conn.get_writer()
        self.screen_tt6_cover = TT6Cover(
            self._screen_tt_addr, self.helper.screen, self._writer
        )
        self.mask_tt6_cover = TT6Cover(
            self._mask_tt_addr, self.helper.mask, self._writer
        )
        await self._start()

    def close(self):
        self._conn.close()
        self._conn = None
        self._message_tracker_reader = None
        self._writer = None
        self.screen_tt6_cover = None
        self.mask_tt6_cover = None

    async def _start(self):
        await self._writer.send_web_on()
        await self.send_pos_request()

    def _get_target_cover(self, tt_addr):
        if tt_addr == self._screen_tt_addr:
            return self.helper.screen
        elif tt_addr == self._mask_tt_addr:
            return self.helper.mask
        else:
            return None

    async def message_tracker(self):
        """Listen to PctPosResponse messages and keep screen and mask up to date"""
        _LOGGER.debug("pos message tracker started")
        async for msg in self._message_tracker_reader:
            _LOGGER.debug(f"msg:{msg}")
            if isinstance(msg, PctPosResponse):
                target_cover = self._get_target_cover(msg.tt_addr)
                if target_cover is not None:
                    await target_cover.set_drop_pct(msg.pct_pos / 1000.0)
                    _LOGGER.debug(
                        f"aspect_ratio: {self.helper.aspect_ratio}; "
                        f"screen_drop: {self.helper.screen.drop}; "
                        f"mask_drop: {self.helper.mask.drop}"
                    )
        _LOGGER.debug("pos message tracker finished")

    async def wait_for_motion_to_complete(self):
        """
        Poll for motion of *both* screen and mask to complete

        Make sure that Cover.moving() is called when movement
        is initiated for this method to work reliably (see CoverWriter)
        Has the side effect of notifying observers of the idle state
        """
        while True:
            await asyncio.sleep(self.POLLING_INTERVAL)
            if await self.helper.check_for_idle():
                return

    async def send_pos_request(self):
        await self.screen_tt6_cover.send_pos_request()
        await self.mask_tt6_cover.send_pos_request()

    async def send_close_command(self):
        await self.screen_tt6_cover.send_close_command()
        await self.mask_tt6_cover.send_close_command()

    async def send_open_command(self):
        await self.screen_tt6_cover.send_open_command()
        await self.mask_tt6_cover.send_open_command()

    async def send_stop_command(self):
        await self.screen_tt6_cover.send_stop_command()
        await self.mask_tt6_cover.send_stop_command()

    async def send_set_aspect_ratio(self, *args, **kwargs):
        new_drops = self.helper.calculate_new_drops(*args, **kwargs)
        if new_drops is not None:
            await self.screen_tt6_cover.send_drop_pct_command(new_drops[0])
            await self.mask_tt6_cover.send_drop_pct_command(new_drops[1])
