{"version":3,"sources":["webpack:///./app/actions/projectActions.tsx","webpack:///./app/actions/teamActions.tsx","webpack:///./app/stores/projectsStore.tsx","webpack:///./app/utils/withApi.tsx","webpack:///./app/utils/withProjects.tsx","webpack:///../node_modules/core-js/modules/es.array.find-index.js","webpack:///../node_modules/lodash/_arrayIncludes.js","webpack:///../node_modules/lodash/_arrayIncludesWith.js","webpack:///../node_modules/lodash/_baseIndexOf.js","webpack:///../node_modules/lodash/_baseIsNaN.js","webpack:///../node_modules/lodash/_baseUniq.js","webpack:///../node_modules/lodash/_createSet.js","webpack:///../node_modules/lodash/_isIterateeCall.js","webpack:///../node_modules/lodash/_strictIndexOf.js","webpack:///../node_modules/lodash/noop.js"],"names":["Reflux","storeConfig","itemsById","loading","init","this","reset","listenTo","ProjectActions","onAddTeam","onChangeSlug","onCreateSuccess","loadInitialData","onStatsLoadSuccess","onRemoveTeam","onUpdateSuccess","TeamActions","onDeleteTeam","items","reduce","map","project","id","trigger","Set","Object","keys","prevSlug","newSlug","prevProject","getBySlug","newProject","slug","data","getById","assign","touchedIds","entries","forEach","projectId","stats","push","teamSlug","projectIds","getWithTeam","projectWithTeam","removeTeamFromProject","projectSlug","team","teams","newTeams","filter","getAll","find","values","sort","a","b","getBySlugs","slugs","includes","getState","projects","WrappedComponent","persistInFlight","props","api","Client","clear","React","getDisplayName","createReactClass","displayName","mixins","ProjectsStore","getInitialState","onProjectUpdate","setState","render","state","loadingProjects","$","$findIndex","addToUnscopables","FIND_INDEX","SKIPS_HOLES","Array","target","proto","forced","findIndex","callbackfn","arguments","length","undefined","baseIndexOf","module","exports","array","value","comparator","index","baseFindIndex","baseIsNaN","strictIndexOf","fromIndex","SetCache","arrayIncludes","arrayIncludesWith","cacheHas","createSet","setToArray","iteratee","isCommon","result","seen","set","outer","computed","seenIndex","noop","eq","isArrayLike","isIndex","isObject","object","type"],"mappings":"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","file":"app_utils_withApi_tsx-app_utils_withProjects_tsx-node_modules_core-js_modules_es_array_find-i-f88899.cbdd1c55744029876d50.js","sourcesContent":["import Reflux from 'reflux';\n\nexport default Reflux.createActions([\n  'addTeam',\n  'addTeamError',\n  'addTeamSuccess',\n  'changeSlug',\n  'createSuccess',\n  'loadProjects',\n  'loadStats',\n  'loadStatsError',\n  'loadStatsForProjectSuccess',\n  'loadStatsSuccess',\n  'removeProject',\n  'removeProjectError',\n  'removeProjectSuccess',\n  'removeTeam',\n  'removeTeamError',\n  'removeTeamSuccess',\n  'reset',\n  'setActive',\n  'update',\n  'updateError',\n  'updateSuccess',\n]);\n","import Reflux from 'reflux';\n\nconst TeamActions = Reflux.createActions([\n  'createTeam',\n  'createTeamError',\n  'createTeamSuccess',\n  'fetchAll',\n  'fetchAllError',\n  'fetchAllSuccess',\n  'fetchDetails',\n  'fetchDetailsError',\n  'fetchDetailsSuccess',\n  'loadTeams',\n  'removeTeam',\n  'removeTeamError',\n  'removeTeamSuccess',\n  'update',\n  'updateError',\n  'updateSuccess',\n]);\n\nexport default TeamActions;\n","import Reflux from 'reflux';\n\nimport ProjectActions from 'app/actions/projectActions';\nimport TeamActions from 'app/actions/teamActions';\nimport {Project, Team} from 'app/types';\n\ntype State = {\n  projects: Project[];\n  loading: boolean;\n};\n\ntype StatsData = Record<string, Project['stats']>;\n\n/**\n * Attributes that need typing but aren't part of the external interface,\n */\ntype Internals = {\n  itemsById: Record<string, Project>;\n  loading: boolean;\n};\n\ntype ProjectsStoreInterface = {\n  init: () => void;\n  reset: () => void;\n  loadInitialData: (projects: Project[]) => void;\n  onStatsLoadSuccess: (data: StatsData) => void;\n  onChangeSlug: (prevSlug: string, newSlug: string) => void;\n  onCreateSuccess: (project: Project) => void;\n  onUpdateSuccess: (data: Partial<Project>) => void;\n  onDeleteTeam: (slug: string) => void;\n  onRemoveTeam: (teamSlug: string, projectSlug: string) => void;\n  onAddTeam: (team: Team, projectSlug: string) => void;\n  removeTeamFromProject: (teamSlug: string, project: Project) => void;\n  getWithTeam: (teamSlug: string) => Project[];\n  getAll: () => Project[];\n  getBySlugs: (slug: string[]) => Project[];\n  getState: (slugs?: string[]) => State;\n  getById: (id?: string) => Project | undefined;\n  getBySlug: (slug?: string) => Project | undefined;\n};\n\nconst storeConfig: Reflux.StoreDefinition & Internals & ProjectsStoreInterface = {\n  itemsById: {},\n  loading: true,\n\n  init() {\n    this.reset();\n\n    this.listenTo(ProjectActions.addTeamSuccess, this.onAddTeam);\n    this.listenTo(ProjectActions.changeSlug, this.onChangeSlug);\n    this.listenTo(ProjectActions.createSuccess, this.onCreateSuccess);\n    this.listenTo(ProjectActions.loadProjects, this.loadInitialData);\n    this.listenTo(ProjectActions.loadStatsSuccess, this.onStatsLoadSuccess);\n    this.listenTo(ProjectActions.removeTeamSuccess, this.onRemoveTeam);\n    this.listenTo(ProjectActions.reset, this.reset);\n    this.listenTo(ProjectActions.updateSuccess, this.onUpdateSuccess);\n\n    this.listenTo(TeamActions.removeTeamSuccess, this.onDeleteTeam);\n  },\n\n  reset() {\n    this.itemsById = {};\n    this.loading = true;\n  },\n\n  loadInitialData(items: Project[]) {\n    this.itemsById = items.reduce((map, project) => {\n      map[project.id] = project;\n      return map;\n    }, {});\n    this.loading = false;\n    this.trigger(new Set(Object.keys(this.itemsById)));\n  },\n\n  onChangeSlug(prevSlug: string, newSlug: string) {\n    const prevProject = this.getBySlug(prevSlug);\n\n    // This shouldn't happen\n    if (!prevProject) {\n      return;\n    }\n\n    const newProject = {\n      ...prevProject,\n      slug: newSlug,\n    };\n\n    this.itemsById = {\n      ...this.itemsById,\n      [newProject.id]: newProject,\n    };\n\n    // Ideally we'd always trigger this.itemsById, but following existing patterns\n    // so we don't break things\n    this.trigger(new Set([prevProject.id]));\n  },\n\n  onCreateSuccess(project: Project) {\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: project,\n    };\n    this.trigger(new Set([project.id]));\n  },\n\n  onUpdateSuccess(data: Partial<Project>) {\n    const project = this.getById(data.id);\n    if (!project) {\n      return;\n    }\n    const newProject = Object.assign({}, project, data);\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: newProject,\n    };\n    this.trigger(new Set([data.id]));\n  },\n\n  onStatsLoadSuccess(data) {\n    const touchedIds: string[] = [];\n    Object.entries(data || {}).forEach(([projectId, stats]) => {\n      if (projectId in this.itemsById) {\n        this.itemsById[projectId].stats = stats;\n        touchedIds.push(projectId);\n      }\n    });\n    this.trigger(new Set(touchedIds));\n  },\n\n  /**\n   * Listener for when a team is completely removed\n   *\n   * @param teamSlug Team Slug\n   */\n  onDeleteTeam(teamSlug: string) {\n    // Look for team in all projects\n    const projectIds = this.getWithTeam(teamSlug).map(projectWithTeam => {\n      this.removeTeamFromProject(teamSlug, projectWithTeam);\n      return projectWithTeam.id;\n    });\n\n    this.trigger(new Set([projectIds]));\n  },\n\n  onRemoveTeam(teamSlug: string, projectSlug: string) {\n    const project = this.getBySlug(projectSlug);\n    if (!project) {\n      return;\n    }\n\n    this.removeTeamFromProject(teamSlug, project);\n    this.trigger(new Set([project.id]));\n  },\n\n  onAddTeam(team: Team, projectSlug: string) {\n    const project = this.getBySlug(projectSlug);\n\n    // Don't do anything if we can't find a project\n    if (!project) {\n      return;\n    }\n\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: {\n        ...project,\n        teams: [...project.teams, team],\n      },\n    };\n\n    this.trigger(new Set([project.id]));\n  },\n\n  // Internal method, does not trigger\n  removeTeamFromProject(teamSlug: string, project: Project) {\n    const newTeams = project.teams.filter(({slug}) => slug !== teamSlug);\n\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: {\n        ...project,\n        teams: newTeams,\n      },\n    };\n  },\n\n  /**\n   * Returns a list of projects that has the specified team\n   *\n   * @param {String} teamSlug Slug of team to find in projects\n   */\n  getWithTeam(teamSlug: string) {\n    return this.getAll().filter(({teams}) => teams.find(({slug}) => slug === teamSlug));\n  },\n\n  getAll() {\n    return Object.values(this.itemsById).sort((a: Project, b: Project) => {\n      if (a.slug > b.slug) {\n        return 1;\n      }\n      if (a.slug < b.slug) {\n        return -1;\n      }\n      return 0;\n    });\n  },\n\n  getById(id) {\n    return this.getAll().find(project => project.id === id);\n  },\n\n  getBySlug(slug) {\n    return this.getAll().find(project => project.slug === slug);\n  },\n\n  getBySlugs(slugs: string[]) {\n    return this.getAll().filter(project => slugs.includes(project.slug));\n  },\n\n  getState(slugs?: string[]): State {\n    return {\n      projects: slugs ? this.getBySlugs(slugs) : this.getAll(),\n      loading: this.loading,\n    };\n  },\n};\n\ntype ProjectsStore = Reflux.Store & ProjectsStoreInterface;\n\nconst ProjectsStore = Reflux.createStore(storeConfig) as ProjectsStore;\n\nexport default ProjectsStore;\n","import * as React from 'react';\n\nimport {Client} from 'app/api';\nimport getDisplayName from 'app/utils/getDisplayName';\n\ntype InjectedApiProps = {\n  api: Client;\n};\n\ntype WrappedProps<P> = Omit<P, keyof InjectedApiProps> & Partial<InjectedApiProps>;\n\ntype OptionProps = {\n  /**\n   * Enabling this option will disable clearing in-flight requests when the\n   * component is unmounted.\n   *\n   * This may be useful in situations where your component needs to finish up\n   * some where the client was passed into some type of action creator and the\n   * component is unmounted.\n   */\n  persistInFlight?: boolean;\n};\n\n/**\n * React Higher-Order Component (HoC) that provides \"api\" client when mounted,\n * and clears API requests when component is unmounted.\n */\nconst withApi = <P extends InjectedApiProps>(\n  WrappedComponent: React.ComponentType<P>,\n  {persistInFlight}: OptionProps = {}\n) =>\n  class extends React.Component<WrappedProps<P>> {\n    static displayName = `withApi(${getDisplayName(WrappedComponent)})`;\n\n    constructor(props: WrappedProps<P>) {\n      super(props);\n      this.api = new Client();\n    }\n\n    componentWillUnmount() {\n      if (!persistInFlight) {\n        this.api.clear();\n      }\n    }\n\n    private api: Client;\n\n    render() {\n      const {api, ...props} = this.props;\n      return <WrappedComponent {...({api: api ?? this.api, ...props} as P)} />;\n    }\n  };\n\nexport default withApi;\n","import * as React from 'react';\nimport createReactClass from 'create-react-class';\nimport Reflux from 'reflux';\n\nimport ProjectsStore from 'app/stores/projectsStore';\nimport {Project} from 'app/types';\nimport getDisplayName from 'app/utils/getDisplayName';\n\ntype InjectedProjectsProps = {\n  projects: Project[];\n  loadingProjects?: boolean;\n};\n\ntype State = {\n  projects: Project[];\n  loading: boolean;\n};\n\n/**\n * Higher order component that uses ProjectsStore and provides a list of projects\n */\nconst withProjects = <P extends InjectedProjectsProps>(\n  WrappedComponent: React.ComponentType<P>\n) =>\n  createReactClass<\n    Omit<P, keyof InjectedProjectsProps> & Partial<InjectedProjectsProps>,\n    State\n  >({\n    displayName: `withProjects(${getDisplayName(WrappedComponent)})`,\n    mixins: [Reflux.listenTo(ProjectsStore, 'onProjectUpdate') as any],\n    getInitialState() {\n      return ProjectsStore.getState();\n    },\n\n    onProjectUpdate() {\n      this.setState(ProjectsStore.getState());\n    },\n    render() {\n      return (\n        <WrappedComponent\n          {...this.props}\n          projects={this.state.projects}\n          loadingProjects={this.state.loading}\n        />\n      );\n    },\n  });\n\nexport default withProjects;\n","'use strict';\nvar $ = require('../internals/export');\nvar $findIndex = require('../internals/array-iteration').findIndex;\nvar addToUnscopables = require('../internals/add-to-unscopables');\n\nvar FIND_INDEX = 'findIndex';\nvar SKIPS_HOLES = true;\n\n// Shouldn't skip holes\nif (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });\n\n// `Array.prototype.findIndex` method\n// https://tc39.es/ecma262/#sec-array.prototype.findindex\n$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {\n  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(FIND_INDEX);\n","var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n"],"sourceRoot":""}