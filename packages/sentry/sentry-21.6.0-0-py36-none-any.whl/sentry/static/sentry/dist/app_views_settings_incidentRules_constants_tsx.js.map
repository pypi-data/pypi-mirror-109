{"version":3,"sources":["webpack:///./app/views/alerts/types.tsx","webpack:///./app/views/alerts/utils/index.tsx","webpack:///./app/views/settings/incidentRules/constants.tsx","webpack:///./app/views/alerts/utils/getIncidentRuleDiscoverUrl.tsx","webpack:///./app/views/settings/incidentRules/incidentRulePresets.tsx","webpack:///./app/views/alerts/utils/getIncidentDiscoverUrl.tsx","webpack:///./app/views/settings/incidentRules/presets.tsx","webpack:///./app/views/settings/incidentRules/types.tsx"],"names":["IncidentType","IncidentActivityType","IncidentStatus","IncidentStatusMethod","AlertRuleStatus","uncancellableApi","Client","fetchAlertRule","orgId","ruleId","requestPromise","fetchIncidentsForRule","alertRule","start","end","query","includeSnapshots","expand","fetchIncident","api","alertId","fetchIncidentStats","updateSubscription","isSubscribed","method","updateStatus","status","data","isOpen","incident","getIncidentMetricPreset","aggregate","dataset","Dataset","PRESET_AGGREGATES","p","validDataset","includes","match","test","getStartEndFromStats","stats","getUtcDateString","eventStats","length","isIssueAlert","hasOwnProperty","DATA_SOURCE_LABELS","t","Datasource","DATA_SOURCE_TO_SET_AND_EVENT_TYPES","eventTypes","EventTypes","convertDatasetEventTypesToSource","getQueryDatasource","slice","sort","join","source","replace","trim","toUpperCase","DEFAULT_AGGREGATE","DEFAULT_TRANSACTION_AGGREGATE","DATASET_EVENT_TYPE_FILTERS","DATASOURCE_EVENT_TYPE_FILTERS","errorFieldConfig","aggregations","fields","commonAggregations","allAggregations","getWizardAlertFieldConfig","alertType","measurementKeys","Object","keys","WEB_VITAL_DETAILS","transactionFieldConfig","createDefaultTrigger","label","alertThreshold","actions","createDefaultRule","timeWindow","triggers","projects","environment","resolveThreshold","thresholdType","AlertRuleThresholdType","createRuleFromEventView","eventView","parsedQuery","datasetAndEventtypes","getYAxis","createRuleFromWizardTemplate","wizardTemplate","aggregateDataset","getIncidentRuleDiscoverUrl","opts","orgSlug","rule","extraQueryParams","timeWindowString","discoverQuery","id","undefined","name","orderby","getAggregateAlias","yAxis","filter","slug","map","Number","version","EventView","getResultsViewUrlTarget","toObject","interval","makeDefaultCta","buttonText","to","display","DisplayModes","getIncidentDiscoverUrl","title","default","makeCtaParams","makeGenericTransactionCta","tooltip","transaction","tokenizeSearch","getTagValues","find","period","transactionSummaryRouteWithQuery","projectID","Set","AlertRuleThreshold","TimePeriod","TimeWindow","ActionType","TargetType","ActionLabel","EMAIL","SLACK","PAGERDUTY","MSTEAMS","SENTRY_APP","TargetLabel","USER","TEAM"],"mappings":"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","file":"app_views_settings_incidentRules_constants_tsx.116e288188e88410daa9.js","sourcesContent":["import {Repository, User} from 'app/types';\nimport {IssueAlertRule} from 'app/types/alerts';\nimport {IncidentRule} from 'app/views/settings/incidentRules/types';\n\ntype Data = [number, {count: number}[]][];\n\nexport type Incident = {\n  dateClosed: string | null;\n  dateStarted: string;\n  dateDetected: string;\n  dateCreated: string;\n  id: string;\n  identifier: string;\n  isSubscribed: boolean;\n  groups: string[]; // Array of group ids\n  discoverQuery: string;\n  organizationId: string;\n  projects: string[]; // Array of slugs\n  seenBy: User[];\n  status: IncidentStatus;\n  statusMethod: IncidentStatusMethod;\n  title: string;\n  hasSeen: boolean;\n  alertRule: IncidentRule;\n  activities?: ActivityType[];\n};\n\nexport type IncidentStats = {\n  eventStats: {\n    data: Data;\n  };\n  totalEvents: number;\n  uniqueUsers: number;\n};\n\nexport type IncidentSuspect = {\n  author: User;\n  dateCreated: string;\n  id: string;\n  message: string;\n  repository: Repository;\n};\n\nexport type ActivityTypeDraft = {\n  comment: null | string;\n  dateCreated: string;\n  id: string;\n  incidentIdentifier: string;\n  type: IncidentActivityType;\n  user: User | null;\n};\n\nexport type ActivityType = ActivityTypeDraft & {\n  eventStats?: {data: Data};\n  previousValue: string | null;\n  value: string | null;\n};\n\nexport enum IncidentType {\n  DETECTED,\n  CREATED,\n  TRIGGERED,\n}\n\nexport enum IncidentActivityType {\n  CREATED = 0,\n  DETECTED = 1,\n  STATUS_CHANGE = 2,\n  COMMENT = 3,\n  STARTED = 4,\n}\n\nexport enum IncidentStatus {\n  OPENED = 1,\n  CLOSED = 2,\n  WARNING = 10,\n  CRITICAL = 20,\n}\n\nexport enum IncidentStatusMethod {\n  MANUAL = 1,\n  RULE_UPDATED = 2,\n  RULE_TRIGGERED = 3,\n}\n\nexport enum AlertRuleStatus {\n  PENDING = 0,\n  SNAPSHOT = 4,\n  DISABLED = 5,\n}\n\nexport type CombinedMetricIssueAlerts = (IssueAlertRule | IncidentRule) & {\n  type: string;\n  latestIncident?: Incident | null;\n};\n","import {Client} from 'app/api';\nimport {t} from 'app/locale';\nimport {NewQuery, Project} from 'app/types';\nimport {IssueAlertRule} from 'app/types/alerts';\nimport {getUtcDateString} from 'app/utils/dates';\nimport EventView from 'app/utils/discover/eventView';\nimport {getAggregateAlias} from 'app/utils/discover/fields';\nimport {ALERT_RULE_PRESET_AGGREGATES} from 'app/views/settings/incidentRules/incidentRulePresets';\nimport {PRESET_AGGREGATES} from 'app/views/settings/incidentRules/presets';\nimport {\n  Dataset,\n  Datasource,\n  EventTypes,\n  IncidentRule,\n  SavedIncidentRule,\n} from 'app/views/settings/incidentRules/types';\n\nimport {Incident, IncidentStats, IncidentStatus} from '../types';\n\n// Use this api for requests that are getting cancelled\nconst uncancellableApi = new Client();\n\nexport function fetchAlertRule(orgId: string, ruleId: string): Promise<IncidentRule> {\n  return uncancellableApi.requestPromise(\n    `/organizations/${orgId}/alert-rules/${ruleId}/`\n  );\n}\n\nexport function fetchIncidentsForRule(\n  orgId: string,\n  alertRule: string,\n  start: string,\n  end: string\n): Promise<Incident[]> {\n  return uncancellableApi.requestPromise(`/organizations/${orgId}/incidents/`, {\n    query: {\n      alertRule,\n      includeSnapshots: true,\n      start,\n      end,\n      expand: ['activities', 'seen_by', 'original_alert_rule'],\n    },\n  });\n}\n\nexport function fetchIncident(\n  api: Client,\n  orgId: string,\n  alertId: string\n): Promise<Incident> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/`);\n}\n\nexport function fetchIncidentStats(\n  api: Client,\n  orgId: string,\n  alertId: string\n): Promise<IncidentStats> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/stats/`);\n}\n\nexport function updateSubscription(\n  api: Client,\n  orgId: string,\n  alertId: string,\n  isSubscribed?: boolean\n): Promise<Incident> {\n  const method = isSubscribed ? 'POST' : 'DELETE';\n  return api.requestPromise(\n    `/organizations/${orgId}/incidents/${alertId}/subscriptions/`,\n    {\n      method,\n    }\n  );\n}\n\nexport function updateStatus(\n  api: Client,\n  orgId: string,\n  alertId: string,\n  status: IncidentStatus\n): Promise<Incident> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/`, {\n    method: 'PUT',\n    data: {\n      status,\n    },\n  });\n}\n\n/**\n * Is incident open?\n *\n * @param {Object} incident Incident object\n * @returns {Boolean}\n */\nexport function isOpen(incident: Incident): boolean {\n  switch (incident.status) {\n    case IncidentStatus.CLOSED:\n      return false;\n    default:\n      return true;\n  }\n}\n\nexport function getIncidentMetricPreset(incident: Incident) {\n  const alertRule = incident?.alertRule;\n  const aggregate = alertRule?.aggregate ?? '';\n  const dataset = alertRule?.dataset ?? Dataset.ERRORS;\n\n  return PRESET_AGGREGATES.find(\n    p => p.validDataset.includes(dataset) && p.match.test(aggregate)\n  );\n}\n\nexport function getIncidentRuleMetricPreset(rule?: IncidentRule) {\n  const aggregate = rule?.aggregate ?? '';\n  const dataset = rule?.dataset ?? Dataset.ERRORS;\n\n  return ALERT_RULE_PRESET_AGGREGATES.find(\n    p => p.validDataset.includes(dataset) && p.match.test(aggregate)\n  );\n}\n\n/**\n * Gets start and end date query parameters from stats\n */\nexport function getStartEndFromStats(stats: IncidentStats) {\n  const start = getUtcDateString(stats.eventStats.data[0][0] * 1000);\n  const end = getUtcDateString(\n    stats.eventStats.data[stats.eventStats.data.length - 1][0] * 1000\n  );\n\n  return {start, end};\n}\n\n/**\n * Gets the URL for a discover view of the incident with the following default\n * parameters:\n *\n * - Ordered by the incident aggregate, descending\n * - yAxis maps to the aggregate\n * - The following fields are displayed:\n *   - For Error dataset alerts: [issue, count(), count_unique(user)]\n *   - For Transaction dataset alerts: [transaction, count()]\n * - Start and end are scoped to the same period as the alert rule\n */\nexport function getIncidentDiscoverUrl(opts: {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n  extraQueryParams?: Partial<NewQuery>;\n}) {\n  const {orgSlug, projects, incident, stats, extraQueryParams} = opts;\n\n  if (!projects || !projects.length || !incident || !stats) {\n    return '';\n  }\n\n  const timeWindowString = `${incident.alertRule.timeWindow}m`;\n  const {start, end} = getStartEndFromStats(stats);\n\n  const discoverQuery: NewQuery = {\n    id: undefined,\n    name: (incident && incident.title) || '',\n    orderby: `-${getAggregateAlias(incident.alertRule.aggregate)}`,\n    yAxis: incident.alertRule.aggregate,\n    query: incident?.discoverQuery ?? '',\n    projects: projects\n      .filter(({slug}) => incident.projects.includes(slug))\n      .map(({id}) => Number(id)),\n    version: 2,\n    fields:\n      incident.alertRule.dataset === Dataset.ERRORS\n        ? ['issue', 'count()', 'count_unique(user)']\n        : ['transaction', incident.alertRule.aggregate],\n    start,\n    end,\n    ...extraQueryParams,\n  };\n\n  const discoverView = EventView.fromSavedQuery(discoverQuery);\n  const {query, ...toObject} = discoverView.getResultsViewUrlTarget(orgSlug);\n\n  return {\n    query: {...query, interval: timeWindowString},\n    ...toObject,\n  };\n}\n\nexport function isIssueAlert(\n  data: IssueAlertRule | SavedIncidentRule | IncidentRule\n): data is IssueAlertRule {\n  return !data.hasOwnProperty('triggers');\n}\n\nexport const DATA_SOURCE_LABELS = {\n  [Dataset.ERRORS]: t('Errors'),\n  [Dataset.TRANSACTIONS]: t('Transactions'),\n  [Datasource.ERROR_DEFAULT]: t('event.type:error OR event.type:default'),\n  [Datasource.ERROR]: t('event.type:error'),\n  [Datasource.DEFAULT]: t('event.type:default'),\n  [Datasource.TRANSACTION]: t('event.type:transaction'),\n};\n\n// Maps a datasource to the relevant dataset and event_types for the backend to use\nexport const DATA_SOURCE_TO_SET_AND_EVENT_TYPES = {\n  [Datasource.ERROR_DEFAULT]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR, EventTypes.DEFAULT],\n  },\n  [Datasource.ERROR]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR],\n  },\n  [Datasource.DEFAULT]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.DEFAULT],\n  },\n  [Datasource.TRANSACTION]: {\n    dataset: Dataset.TRANSACTIONS,\n    eventTypes: [EventTypes.TRANSACTION],\n  },\n};\n\n// Converts the given dataset and event types array to a datasource for the datasource dropdown\nexport function convertDatasetEventTypesToSource(\n  dataset: Dataset,\n  eventTypes: EventTypes[]\n) {\n  // transactions only has one datasource option regardless of event type\n  if (dataset === Dataset.TRANSACTIONS) {\n    return Datasource.TRANSACTION;\n  }\n  // if no event type was provided use the default datasource\n  if (!eventTypes) {\n    return Datasource.ERROR;\n  }\n\n  if (eventTypes.includes(EventTypes.DEFAULT) && eventTypes.includes(EventTypes.ERROR)) {\n    return Datasource.ERROR_DEFAULT;\n  } else if (eventTypes.includes(EventTypes.DEFAULT)) {\n    return Datasource.DEFAULT;\n  } else {\n    return Datasource.ERROR;\n  }\n}\n\n/**\n * Attempt to guess the data source of a discover query\n *\n * @returns An object containing the datasource and new query without the datasource.\n * Returns null on no datasource.\n */\nexport function getQueryDatasource(\n  query: string\n): {source: Datasource; query: string} | null {\n  let match = query.match(\n    /\\(?\\bevent\\.type:(error|default|transaction)\\)?\\WOR\\W\\(?event\\.type:(error|default|transaction)\\)?/i\n  );\n  if (match) {\n    // should be [error, default] or [default, error]\n    const eventTypes = match.slice(1, 3).sort().join(',');\n    if (eventTypes !== 'default,error') {\n      return null;\n    }\n\n    return {source: Datasource.ERROR_DEFAULT, query: query.replace(match[0], '').trim()};\n  }\n\n  match = query.match(/(^|\\s)event\\.type:(error|default|transaction)/i);\n  if (match && Datasource[match[2].toUpperCase()]) {\n    return {\n      source: Datasource[match[2].toUpperCase()],\n      query: query.replace(match[0], '').trim(),\n    };\n  }\n\n  return null;\n}\n","import EventView from 'app/utils/discover/eventView';\nimport {AggregationKey, LooseFieldKey} from 'app/utils/discover/fields';\nimport {WEB_VITAL_DETAILS} from 'app/utils/performance/vitals/constants';\nimport {\n  DATA_SOURCE_TO_SET_AND_EVENT_TYPES,\n  getQueryDatasource,\n} from 'app/views/alerts/utils';\nimport {AlertType, WizardRuleTemplate} from 'app/views/alerts/wizard/options';\nimport {\n  AlertRuleThresholdType,\n  Dataset,\n  Datasource,\n  EventTypes,\n  Trigger,\n  UnsavedIncidentRule,\n} from 'app/views/settings/incidentRules/types';\n\nexport const DEFAULT_AGGREGATE = 'count()';\nexport const DEFAULT_TRANSACTION_AGGREGATE = 'p95(transaction.duration)';\n\nexport const DATASET_EVENT_TYPE_FILTERS = {\n  [Dataset.ERRORS]: 'event.type:error',\n  [Dataset.TRANSACTIONS]: 'event.type:transaction',\n} as const;\n\nexport const DATASOURCE_EVENT_TYPE_FILTERS = {\n  [Datasource.ERROR_DEFAULT]: '(event.type:error OR event.type:default)',\n  [Datasource.ERROR]: 'event.type:error',\n  [Datasource.DEFAULT]: 'event.type:default',\n  [Datasource.TRANSACTION]: 'event.type:transaction',\n} as const;\n\nexport type OptionConfig = {\n  aggregations: AggregationKey[];\n  fields: LooseFieldKey[];\n  measurementKeys?: string[];\n};\n\n/**\n * Allowed error aggregations for alerts\n */\nexport const errorFieldConfig: OptionConfig = {\n  aggregations: ['count', 'count_unique'],\n  fields: ['user'],\n};\n\nconst commonAggregations: AggregationKey[] = [\n  'avg',\n  'percentile',\n  'p50',\n  'p75',\n  'p95',\n  'p99',\n  'p100',\n];\n\nconst allAggregations: AggregationKey[] = [\n  ...commonAggregations,\n  'failure_rate',\n  'apdex',\n  'count',\n];\n\nexport function getWizardAlertFieldConfig(\n  alertType: AlertType,\n  dataset: Dataset\n): OptionConfig {\n  if (alertType === 'custom' && dataset === Dataset.ERRORS) {\n    return errorFieldConfig;\n  }\n  // If user selected apdex we must include that in the OptionConfig as it has a user specified column\n  const aggregations =\n    alertType === 'apdex' || alertType === 'custom'\n      ? allAggregations\n      : commonAggregations;\n  return {\n    aggregations,\n    fields: ['transaction.duration'],\n    measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n  };\n}\n\n/**\n * Allowed aggregations for alerts created from wizard\n */\nexport const wizardAlertFieldConfig: OptionConfig = {\n  aggregations: commonAggregations,\n  fields: ['transaction.duration'],\n  measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n};\n\n/**\n * Allowed transaction aggregations for alerts\n */\nexport const transactionFieldConfig: OptionConfig = {\n  aggregations: allAggregations,\n  fields: ['transaction.duration'],\n  measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n};\n\nexport function createDefaultTrigger(label: 'critical' | 'warning'): Trigger {\n  return {\n    label,\n    alertThreshold: '',\n    actions: [],\n  };\n}\n\nexport function createDefaultRule(): UnsavedIncidentRule {\n  return {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR],\n    aggregate: DEFAULT_AGGREGATE,\n    query: '',\n    timeWindow: 1,\n    triggers: [createDefaultTrigger('critical'), createDefaultTrigger('warning')],\n    projects: [],\n    environment: null,\n    resolveThreshold: '',\n    thresholdType: AlertRuleThresholdType.ABOVE,\n  };\n}\n\n/**\n * Create an unsaved alert from a discover EventView object\n */\nexport function createRuleFromEventView(eventView: EventView): UnsavedIncidentRule {\n  const parsedQuery = getQueryDatasource(eventView.query);\n  const datasetAndEventtypes = parsedQuery\n    ? DATA_SOURCE_TO_SET_AND_EVENT_TYPES[parsedQuery.source]\n    : DATA_SOURCE_TO_SET_AND_EVENT_TYPES.error;\n  return {\n    ...createDefaultRule(),\n    ...datasetAndEventtypes,\n    query: parsedQuery?.query ?? eventView.query,\n    // If creating a metric alert for transactions, default to the p95 metric\n    aggregate:\n      datasetAndEventtypes.dataset === 'transactions'\n        ? 'p95(transaction.duration)'\n        : eventView.getYAxis(),\n    environment: eventView.environment.length ? eventView.environment[0] : null,\n  };\n}\n\nexport function createRuleFromWizardTemplate(\n  wizardTemplate: WizardRuleTemplate\n): UnsavedIncidentRule {\n  const {eventTypes, ...aggregateDataset} = wizardTemplate;\n  return {\n    ...createDefaultRule(),\n    eventTypes: [eventTypes],\n    ...aggregateDataset,\n  };\n}\n","import {NewQuery, Project} from 'app/types';\nimport EventView from 'app/utils/discover/eventView';\nimport {getAggregateAlias} from 'app/utils/discover/fields';\nimport {Dataset, IncidentRule} from 'app/views/settings/incidentRules/types';\n/**\n * Gets the URL for a discover view of the rule with the following default\n * parameters:\n *\n * - Ordered by the rule aggregate, descending\n * - yAxis maps to the aggregate\n * - The following fields are displayed:\n *   - For Error dataset alert rules: [issue, count(), count_unique(user)]\n *   - For Transaction dataset alert rules: [transaction, count()]\n * - Start and end are the period's values selected in the chart header\n */\nexport function getIncidentRuleDiscoverUrl(opts: {\n  orgSlug: string;\n  projects: Project[];\n  rule?: IncidentRule;\n  start?: string;\n  end?: string;\n  extraQueryParams?: Partial<NewQuery>;\n}) {\n  const {orgSlug, projects, rule, start, end, extraQueryParams} = opts;\n\n  if (!projects || !projects.length || !rule || (!start && !end)) {\n    return '';\n  }\n\n  const timeWindowString = `${rule.timeWindow}m`;\n\n  const discoverQuery: NewQuery = {\n    id: undefined,\n    name: (rule && rule.name) || '',\n    orderby: `-${getAggregateAlias(rule.aggregate)}`,\n    yAxis: rule.aggregate,\n    query: rule?.query ?? '',\n    projects: projects\n      .filter(({slug}) => rule.projects.includes(slug))\n      .map(({id}) => Number(id)),\n    version: 2,\n    fields:\n      rule.dataset === Dataset.ERRORS\n        ? ['issue', 'count()', 'count_unique(user)']\n        : ['transaction', rule.aggregate],\n    start,\n    end,\n    ...extraQueryParams,\n  };\n\n  const discoverView = EventView.fromSavedQuery(discoverQuery);\n  const {query, ...toObject} = discoverView.getResultsViewUrlTarget(orgSlug);\n\n  return {\n    query: {...query, interval: timeWindowString},\n    ...toObject,\n  };\n}\n","import Link from 'app/components/links/link';\nimport {t} from 'app/locale';\nimport {Project} from 'app/types';\nimport {DisplayModes} from 'app/utils/discover/types';\nimport {tokenizeSearch} from 'app/utils/tokenizeSearch';\nimport {getIncidentRuleDiscoverUrl} from 'app/views/alerts/utils/getIncidentRuleDiscoverUrl';\nimport {transactionSummaryRouteWithQuery} from 'app/views/performance/transactionSummary/utils';\nimport {Dataset, IncidentRule} from 'app/views/settings/incidentRules/types';\n\ntype PresetCta = {\n  /**\n   * The location to direct to upon clicking the CTA.\n   */\n  to: React.ComponentProps<typeof Link>['to'];\n  /**\n   * The CTA text\n   */\n  buttonText: string;\n  /**\n   * The tooltip title for the CTA button, may be empty.\n   */\n  title?: string;\n};\n\ntype PresetCtaOpts = {\n  orgSlug: string;\n  projects: Project[];\n  rule?: IncidentRule;\n  start?: string;\n  end?: string;\n};\n\ntype Preset = {\n  /**\n   * The regex used to match aggregates to this preset.\n   */\n  match: RegExp;\n  /**\n   * The name of the preset\n   */\n  name: string;\n  /**\n   * The dataset that this preset applys to.\n   */\n  validDataset: Dataset[];\n  /**\n   * The default aggregate to use when selecting this preset\n   */\n  default: string;\n  /**\n   * Generates the CTA component\n   */\n  makeCtaParams: (opts: PresetCtaOpts) => PresetCta;\n};\n\nexport const ALERT_RULE_PRESET_AGGREGATES: Preset[] = [\n  {\n    name: t('Error count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count()',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Users affected'),\n    match: /^count_unique\\(tags\\[sentry:user\\]\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count_unique(tags[sentry:user])',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Latency'),\n    match: /^(p[0-9]{2,3}|percentile\\(transaction\\.duration,[^)]+\\)|avg\\([^)]+\\))/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'percentile(transaction.duration, 0.95)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Latency by Transaction'),\n      }),\n  },\n  {\n    name: t('Apdex'),\n    match: /^apdex\\([0-9.]+\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'apdex(300)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Apdex by Transaction'),\n      }),\n  },\n  {\n    name: t('Transaction count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'count()',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts => makeGenericTransactionCta({opts}),\n  },\n  {\n    name: t('Failure rate'),\n    match: /^failure_rate\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'failure_rate()',\n    /**\n     * See makeFailureRateCta\n     */\n    makeCtaParams: makeFailureRateCta,\n  },\n];\n\n/**\n * - CASE 1: If has a specific transaction filter\n *   - CTA is: \"View Transaction Summary\"\n *   - Tooltip is the transaction name\n *   - the same period as the alert rule graph\n *\n * - CASE 2: If transaction is NOT filtered, or has a * filter:\n *   - \"Open in Discover\" button with optional tooltip which opens a discover view with...\n *      - fields {transaction, count(), <metric>} sorted by count()\n *      - top-5 activated\n */\nfunction makeGenericTransactionCta(opts: {\n  opts: PresetCtaOpts;\n  tooltip?: string;\n}): PresetCta {\n  const {\n    opts: {orgSlug, projects, rule, start, end},\n    tooltip,\n  } = opts;\n\n  if (!rule || (!start && !end)) {\n    return {to: '', buttonText: t('Alert rule details')};\n  }\n\n  const query = tokenizeSearch(rule.query ?? '');\n  const transaction = query\n    .getTagValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  // CASE 1\n  if (transaction !== undefined) {\n    const summaryUrl = transactionSummaryRouteWithQuery({\n      orgSlug,\n      transaction,\n      projectID: projects\n        .filter(({slug}) => rule.projects.includes(slug))\n        .map(({id}) => id),\n      query: {start, end},\n    });\n\n    return {\n      to: summaryUrl,\n      buttonText: t('View Transaction Summary'),\n      title: transaction,\n    };\n  }\n\n  // CASE 2\n  const extraQueryParams = {\n    fields: [...new Set(['transaction', 'count()', rule.aggregate])],\n    orderby: '-count',\n    display: DisplayModes.TOP5,\n  };\n\n  const discoverUrl = getIncidentRuleDiscoverUrl({\n    orgSlug,\n    projects,\n    rule,\n    start,\n    end,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: tooltip,\n  };\n}\n\n/**\n * - CASE 1: Filtered to a specific transaction, \"Open in Discover\" with...\n *   - fields [transaction.status, count()] sorted by count(),\n *   - \"Top 5 period\" activated.\n *\n * - CASE 2: If filtered on multiple transactions, \"Open in Discover\" button\n *   with tooltip \"Failure rate by transaction\" which opens a discover view\n *   - fields [transaction, failure_rate()] sorted by failure_rate\n *   - top 5 activated\n */\nfunction makeFailureRateCta({orgSlug, rule, projects, start, end}: PresetCtaOpts) {\n  if (!rule || (!start && !end)) {\n    return {to: '', buttonText: t('Alert rule details')};\n  }\n\n  const query = tokenizeSearch(rule.query ?? '');\n  const transaction = query\n    .getTagValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  const extraQueryParams =\n    transaction !== undefined\n      ? // CASE 1\n        {\n          fields: ['transaction.status', 'count()'],\n          orderby: '-count',\n          display: DisplayModes.TOP5,\n        }\n      : // Case 2\n        {\n          fields: ['transaction', 'failure_rate()'],\n          orderby: '-failure_rate',\n          display: DisplayModes.TOP5,\n        };\n\n  const discoverUrl = getIncidentRuleDiscoverUrl({\n    orgSlug,\n    projects,\n    rule,\n    start,\n    end,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: transaction === undefined ? t('Failure rate by transaction') : undefined,\n  };\n}\n\n/**\n * Get the CTA used for alert rules that do not have a preset\n */\nexport function makeDefaultCta({\n  orgSlug,\n  projects,\n  rule,\n  start,\n  end,\n}: PresetCtaOpts): PresetCta {\n  if (!rule) {\n    return {\n      buttonText: t('Open in Discover'),\n      to: '',\n    };\n  }\n\n  const extraQueryParams = {\n    display: DisplayModes.TOP5,\n  };\n\n  return {\n    buttonText: t('Open in Discover'),\n    to: getIncidentRuleDiscoverUrl({\n      orgSlug,\n      projects,\n      rule,\n      start,\n      end,\n      extraQueryParams,\n    }),\n  };\n}\n","import {NewQuery, Project} from 'app/types';\nimport EventView from 'app/utils/discover/eventView';\nimport {getAggregateAlias} from 'app/utils/discover/fields';\nimport {Incident, IncidentStats} from 'app/views/alerts/types';\nimport {getStartEndFromStats} from 'app/views/alerts/utils';\nimport {Dataset} from 'app/views/settings/incidentRules/types';\n/**\n * Gets the URL for a discover view of the incident with the following default\n * parameters:\n *\n * - Ordered by the incident aggregate, descending\n * - yAxis maps to the aggregate\n * - The following fields are displayed:\n *   - For Error dataset alerts: [issue, count(), count_unique(user)]\n *   - For Transaction dataset alerts: [transaction, count()]\n * - Start and end are scoped to the same period as the alert rule\n */\nexport function getIncidentDiscoverUrl(opts: {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n  extraQueryParams?: Partial<NewQuery>;\n}) {\n  const {orgSlug, projects, incident, stats, extraQueryParams} = opts;\n\n  if (!projects || !projects.length || !incident || !stats) {\n    return '';\n  }\n\n  const timeWindowString = `${incident.alertRule.timeWindow}m`;\n  const {start, end} = getStartEndFromStats(stats);\n\n  const discoverQuery: NewQuery = {\n    id: undefined,\n    name: (incident && incident.title) || '',\n    orderby: `-${getAggregateAlias(incident.alertRule.aggregate)}`,\n    yAxis: incident.alertRule.aggregate,\n    query: incident?.discoverQuery ?? '',\n    projects: projects\n      .filter(({slug}) => incident.projects.includes(slug))\n      .map(({id}) => Number(id)),\n    version: 2,\n    fields:\n      incident.alertRule.dataset === Dataset.ERRORS\n        ? ['issue', 'count()', 'count_unique(user)']\n        : ['transaction', incident.alertRule.aggregate],\n    start,\n    end,\n    ...extraQueryParams,\n  };\n\n  const discoverView = EventView.fromSavedQuery(discoverQuery);\n  const {query, ...toObject} = discoverView.getResultsViewUrlTarget(orgSlug);\n\n  return {\n    query: {...query, interval: timeWindowString},\n    ...toObject,\n  };\n}\n","import Link from 'app/components/links/link';\nimport {t} from 'app/locale';\nimport {Project} from 'app/types';\nimport {DisplayModes} from 'app/utils/discover/types';\nimport {tokenizeSearch} from 'app/utils/tokenizeSearch';\nimport {Incident, IncidentStats} from 'app/views/alerts/types';\nimport {getStartEndFromStats} from 'app/views/alerts/utils';\nimport {getIncidentDiscoverUrl} from 'app/views/alerts/utils/getIncidentDiscoverUrl';\nimport {transactionSummaryRouteWithQuery} from 'app/views/performance/transactionSummary/utils';\n\nimport {Dataset} from './types';\n\ntype PresetCta = {\n  /**\n   * The location to direct to upon clicking the CTA.\n   */\n  to: React.ComponentProps<typeof Link>['to'];\n  /**\n   * The CTA text\n   */\n  buttonText: string;\n  /**\n   * The tooltip title for the CTA button, may be empty.\n   */\n  title?: string;\n};\n\ntype PresetCtaOpts = {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n};\n\ntype Preset = {\n  /**\n   * The regex used to match aggregates to this preset.\n   */\n  match: RegExp;\n  /**\n   * The name of the preset\n   */\n  name: string;\n  /**\n   * The dataset that this preset applys to.\n   */\n  validDataset: Dataset[];\n  /**\n   * The default aggregate to use when selecting this preset\n   */\n  default: string;\n  /**\n   * Generates the CTA component\n   */\n  makeCtaParams: (opts: PresetCtaOpts) => PresetCta;\n};\n\nexport const PRESET_AGGREGATES: Preset[] = [\n  {\n    name: t('Error count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count()',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Users affected'),\n    match: /^count_unique\\(tags\\[sentry:user\\]\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count_unique(tags[sentry:user])',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Latency'),\n    match: /^(p[0-9]{2,3}|percentile\\(transaction\\.duration,[^)]+\\)|avg\\([^)]+\\))/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'percentile(transaction.duration, 0.95)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Latency by Transaction'),\n      }),\n  },\n  {\n    name: t('Apdex'),\n    match: /^apdex\\([0-9.]+\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'apdex(300)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Apdex by Transaction'),\n      }),\n  },\n  {\n    name: t('Transaction Count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'count()',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts => makeGenericTransactionCta({opts}),\n  },\n  {\n    name: t('Failure rate'),\n    match: /^failure_rate\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'failure_rate()',\n    /**\n     * See makeFailureRateCta\n     */\n    makeCtaParams: makeFailureRateCta,\n  },\n];\n\n/**\n * - CASE 1: If has a specific transaction filter\n *   - CTA is: \"View Transaction Summary\"\n *   - Tooltip is the transaction name\n *   - the same period as the alert graph (i.e. with alert start time in the middle)\n *\n * - CASE 2: If transaction is NOT filtered, or has a * filter:\n *   - \"Open in Discover\" button with optional tooltip which opens a discover view with...\n *      - fields {transaction, count(), <metric>} sorted by count()\n *      - top-5 activated\n */\nfunction makeGenericTransactionCta(opts: {\n  opts: PresetCtaOpts;\n  tooltip?: string;\n}): PresetCta {\n  const {\n    opts: {orgSlug, projects, incident, stats},\n    tooltip,\n  } = opts;\n\n  if (!incident || !stats) {\n    return {to: '', buttonText: t('Incident details')};\n  }\n\n  const query = tokenizeSearch(incident.discoverQuery ?? '');\n  const transaction = query\n    .getTagValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  // CASE 1\n  if (transaction !== undefined) {\n    const period = getStartEndFromStats(stats);\n\n    const summaryUrl = transactionSummaryRouteWithQuery({\n      orgSlug,\n      transaction,\n      projectID: projects\n        .filter(({slug}) => incident.projects.includes(slug))\n        .map(({id}) => id),\n      query: {...period},\n    });\n\n    return {\n      to: summaryUrl,\n      buttonText: t('View Transaction Summary'),\n      title: transaction,\n    };\n  }\n\n  // CASE 2\n  const extraQueryParams = {\n    fields: [...new Set(['transaction', 'count()', incident.alertRule.aggregate])],\n    orderby: '-count',\n    display: DisplayModes.TOP5,\n  };\n\n  const discoverUrl = getIncidentDiscoverUrl({\n    orgSlug,\n    projects,\n    incident,\n    stats,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: tooltip,\n  };\n}\n\n/**\n * - CASE 1: Filtered to a specific transaction, \"Open in Discover\" with...\n *   - fields [transaction.status, count()] sorted by count(),\n *   - \"Top 5 period\" activated.\n *\n * - CASE 2: If filtered on multiple transactions, \"Open in Discover\" button\n *   with tooltip \"Failure rate by transaction\" which opens a discover view\n *   - fields [transaction, failure_rate()] sorted by failure_rate\n *   - top 5 activated\n */\nfunction makeFailureRateCta({orgSlug, incident, projects, stats}: PresetCtaOpts) {\n  if (!incident || !stats) {\n    return {to: '', buttonText: t('Incident details')};\n  }\n\n  const query = tokenizeSearch(incident.discoverQuery ?? '');\n  const transaction = query\n    .getTagValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  const extraQueryParams =\n    transaction !== undefined\n      ? // CASE 1\n        {\n          fields: ['transaction.status', 'count()'],\n          orderby: '-count',\n          display: DisplayModes.TOP5,\n        }\n      : // Case 2\n        {\n          fields: ['transaction', 'failure_rate()'],\n          orderby: '-failure_rate',\n          display: DisplayModes.TOP5,\n        };\n\n  const discoverUrl = getIncidentDiscoverUrl({\n    orgSlug,\n    projects,\n    incident,\n    stats,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: transaction === undefined ? t('Failure rate by transaction') : undefined,\n  };\n}\n\n/**\n * Get the CTA used for alerts that do not have a preset\n */\nexport function makeDefaultCta({\n  orgSlug,\n  projects,\n  incident,\n  stats,\n}: PresetCtaOpts): PresetCta {\n  if (!incident) {\n    return {\n      buttonText: t('Open in Discover'),\n      to: '',\n    };\n  }\n\n  const extraQueryParams = {\n    display: DisplayModes.TOP5,\n  };\n\n  return {\n    buttonText: t('Open in Discover'),\n    to: getIncidentDiscoverUrl({orgSlug, projects, incident, stats, extraQueryParams}),\n  };\n}\n","import {t} from 'app/locale';\n\nexport enum AlertRuleThreshold {\n  INCIDENT,\n  RESOLUTION,\n}\n\nexport enum AlertRuleThresholdType {\n  ABOVE,\n  BELOW,\n}\n\nexport enum Dataset {\n  ERRORS = 'events',\n  TRANSACTIONS = 'transactions',\n}\n\nexport enum EventTypes {\n  DEFAULT = 'default',\n  ERROR = 'error',\n  TRANSACTION = 'transaction',\n}\n\nexport enum Datasource {\n  ERROR_DEFAULT = 'error_default',\n  DEFAULT = 'default',\n  ERROR = 'error',\n  TRANSACTION = 'transaction',\n}\n\nexport type UnsavedTrigger = {\n  // UnsavedTrigger can be apart of an Unsaved Alert Rule that does not have an\n  // id yet\n  alertRuleId?: string;\n  label: string;\n  alertThreshold: number | '' | null;\n  actions: Action[];\n};\n\nexport type ThresholdControlValue = {\n  thresholdType: AlertRuleThresholdType;\n  /**\n   * Resolve threshold is optional, so it can be null\n   */\n  threshold: number | '' | null;\n};\n\nexport type SavedTrigger = Omit<UnsavedTrigger, 'actions'> & {\n  id: string;\n  dateCreated: string;\n  actions: Action[];\n};\n\nexport type Trigger = Partial<SavedTrigger> & UnsavedTrigger;\n\nexport type UnsavedIncidentRule = {\n  dataset: Dataset;\n  projects: string[];\n  environment: string | null;\n  query: string;\n  timeWindow: TimeWindow;\n  triggers: Trigger[];\n  aggregate: string;\n  thresholdType: AlertRuleThresholdType;\n  resolveThreshold: number | '' | null;\n  eventTypes?: EventTypes[];\n  owner?: string | null;\n};\n\nexport type SavedIncidentRule = UnsavedIncidentRule & {\n  dateCreated: string;\n  dateModified: string;\n  id: string;\n  status: number;\n  name: string;\n  createdBy?: {id: number; email: string; name: string} | null;\n  originalAlertRuleId?: number | null;\n};\n\nexport type IncidentRule = Partial<SavedIncidentRule> & UnsavedIncidentRule;\n\nexport enum TimePeriod {\n  SIX_HOURS = '6h',\n  ONE_DAY = '1d',\n  THREE_DAYS = '3d',\n  // Seven days is actually 10080m but we have a max of 10000 events\n  SEVEN_DAYS = '10000m',\n  FOURTEEN_DAYS = '14d',\n  THIRTY_DAYS = '30d',\n}\n\nexport enum TimeWindow {\n  ONE_MINUTE = 1,\n  FIVE_MINUTES = 5,\n  TEN_MINUTES = 10,\n  FIFTEEN_MINUTES = 15,\n  THIRTY_MINUTES = 30,\n  ONE_HOUR = 60,\n  TWO_HOURS = 120,\n  FOUR_HOURS = 240,\n  ONE_DAY = 1440,\n}\n\nexport type ProjectSelectOption = {\n  label: string;\n  value: number;\n};\n\nexport enum ActionType {\n  EMAIL = 'email',\n  SLACK = 'slack',\n  PAGERDUTY = 'pagerduty',\n  MSTEAMS = 'msteams',\n  SENTRY_APP = 'sentry_app',\n}\n\nexport const ActionLabel = {\n  [ActionType.EMAIL]: t('Email'),\n  [ActionType.SLACK]: t('Slack'),\n  [ActionType.PAGERDUTY]: t('Pagerduty'),\n  [ActionType.MSTEAMS]: t('MS Teams'),\n  [ActionType.SENTRY_APP]: t('Notification'),\n};\n\nexport enum TargetType {\n  // A direct reference, like an email address, Slack channel, or PagerDuty service\n  SPECIFIC = 'specific',\n\n  // A specific user. This could be used to grab the user's email address.\n  USER = 'user',\n\n  // A specific team. This could be used to send an email to everyone associated with a team.\n  TEAM = 'team',\n\n  // A Sentry App instead of any of the above.\n  SENTRY_APP = 'sentry_app',\n}\n\nexport const TargetLabel = {\n  [TargetType.USER]: t('Member'),\n  [TargetType.TEAM]: t('Team'),\n};\n\n/**\n * This is an available action template that is associated to a Trigger in a\n * Metric Alert Rule. They are defined by the available-actions API.\n */\nexport type MetricActionTemplate = {\n  /**\n   * The integration type e.g. 'email'\n   */\n  type: ActionType;\n\n  /**\n   * See `TargetType`\n   */\n  allowedTargetTypes: TargetType[];\n\n  /**\n   * Name of the integration. This is a text field that differentiates integrations from the same provider from each other\n   */\n  integrationName?: string;\n\n  /**\n   * Integration id for this `type`, should be passed to backend as `integrationId` when creating an action\n   */\n  integrationId?: number;\n\n  /**\n   * Name of the SentryApp. Like `integrationName`, this differentiates SentryApps from each other.\n   */\n  sentryAppName?: string;\n\n  /**\n   * SentryApp id for this `type`, should be passed to backend as `sentryAppId` when creating an action.\n   */\n  sentryAppId?: number;\n\n  /**\n   * For some available actions, we pass in the list of available targets.\n   */\n  options?: Array<{label: string; value: any}>;\n\n  /**\n   * If this is a `sentry_app` action, this is the Sentry App's status.\n   */\n  status?: 'unpublished' | 'published' | 'internal';\n};\n\n/**\n * This is the user's configured action\n */\nexport type Action = UnsavedAction & Partial<SavedActionFields>;\nexport type SavedAction = Omit<UnsavedAction, 'unsavedDateCreated' | 'unsavedId'> &\n  SavedActionFields;\n\ntype SavedActionFields = {\n  /**\n   * The id of the alert rule this action belongs to\n   */\n  alertRuleTriggerId: string;\n\n  /**\n   * A human readable description of the action generated by server\n   */\n  desc: string;\n\n  /**\n   * model id of the action\n   */\n  id: string;\n\n  /**\n   * date created\n   */\n  dateCreated: string;\n};\n\nexport type UnsavedAction = {\n  unsavedId: string;\n  /** Used to maintain order of unsaved actions */\n  unsavedDateCreated: string;\n  type: ActionType;\n\n  targetType: TargetType | null;\n\n  /**\n   * How to identify the target. Can be email, slack channel, pagerduty service,\n   * user_id, team_id, SentryApp id, etc\n   */\n  targetIdentifier: string | null;\n\n  /**\n   * The id of the integration, can be null (e.g. email) or undefined (server errors when posting w/ null value)\n   */\n  integrationId?: number | null;\n\n  /**\n   * The id of the SentryApp, can be null (e.g. email) or undefined (server errors when posting w/ null value)\n   */\n  sentryAppId?: number | null;\n\n  /**\n   * For some available actions, we pass in the list of available targets.\n   */\n  options: Array<{label: string; value: any}> | null;\n\n  /**\n   * If this is a `sentry_app` action, this is the Sentry App's status.\n   */\n  status?: 'unpublished' | 'published' | 'internal';\n};\n"],"sourceRoot":""}