// Copyright 2021 The TensorStore Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "python/tensorstore/chunk_layout.h"

#include "python/tensorstore/array_type_caster.h"
#include "python/tensorstore/index_space.h"
#include "python/tensorstore/json_type_caster.h"
#include "pybind11/pybind11.h"
#include "pybind11/stl.h"
#include "tensorstore/chunk_layout.h"
#include "tensorstore/index_space/index_domain_builder.h"
#include "tensorstore/internal/json_pprint_python.h"

namespace tensorstore {
namespace internal_python {

namespace py = pybind11;

namespace {

Result<IndexDomain<>> GetChunkTemplateAsIndexDomain(const ChunkLayout& self,
                                                    ChunkLayout::Usage usage) {
  IndexDomainBuilder builder(self.rank());
  builder.origin(self.grid_origin());
  builder.shape(self[usage].shape());
  return builder.Finalize();
}

}  // namespace

void RegisterChunkLayoutBindings(pybind11::module m) {
  // Predefine class types before any methods that use them.  This ensures that
  // the signatures included in the docstrings generated by pybind11 include the
  // correct Python class names, rather than the C++ typeid.
  py::class_<ChunkLayout> chunk_layout_cls(m, "ChunkLayout");
  py::class_<ChunkLayout::Grid> grid_cls(chunk_layout_cls, "Grid");

  grid_cls.def(
      py::init(
          [](std::vector<std::optional<Index>> shape) -> ChunkLayout::Grid {
            const DimensionIndex rank = shape.size();
            ThrowStatusException(ValidateRank(rank));
            ChunkLayout::Grid grid(rank);
            for (DimensionIndex i = 0; i < rank; ++i) {
              grid.shape()[i] = shape[i].value_or(0);
            }
            return grid;
          }),
      "Constructs a chunk grid.", py::arg("shape"));
  grid_cls.def_property_readonly(
      "shape",
      [](const ChunkLayout::Grid& self) -> HomogeneousTuple<Index> {
        return SpanToHomogeneousTuple<Index>(self.shape());
      },
      "Chunk shape");
  grid_cls.def("__eq__",
               [](const ChunkLayout::Grid& self,
                  const ChunkLayout::Grid& other) { return self == other; });

  chunk_layout_cls.def(
      py::init([](::nlohmann::json json) {
        return ValueOrThrow(ChunkLayout::FromJson(std::move(json)));
      }),
      "Constructs a ChunkLayout from a JSON representation.", py::arg("json"));
  chunk_layout_cls.def(
      py::init([](std::optional<DimensionIndex> rank,
                  std::optional<std::vector<DimensionIndex>> inner_order,
                  std::optional<std::vector<Index>> grid_origin,
                  std::optional<ChunkLayout::Grid> write_chunk,
                  std::optional<ChunkLayout::Grid> read_chunk,
                  std::optional<ChunkLayout::Grid> codec_chunk) {
        ChunkLayout::Builder builder;
        const auto validate_rank = [&](DimensionIndex new_rank) {
          ThrowStatusException(ValidateRank(new_rank));
          if (!builder.valid()) {
            builder = ChunkLayout::Builder(new_rank);
          } else if (builder.rank() != new_rank) {
            ThrowStatusException(absl::InvalidArgumentError(tensorstore::StrCat(
                "Rank mismatch: ", builder.rank(), " vs ", new_rank)));
          }
        };
        if (rank) {
          validate_rank(*rank);
        }
        if (inner_order) {
          validate_rank(inner_order->size());
          builder.inner_order(*inner_order);
        }
        if (grid_origin) {
          validate_rank(grid_origin->size());
          builder.grid_origin(*grid_origin);
        }
        if (write_chunk) {
          validate_rank(write_chunk->rank());
          builder.write_chunk(*write_chunk);
        }
        if (read_chunk) {
          validate_rank(read_chunk->rank());
          builder.read_chunk(*read_chunk);
        }
        if (codec_chunk) {
          validate_rank(codec_chunk->rank());
          builder.codec_chunk(*codec_chunk);
        }
        if (!builder.valid()) {
          ThrowStatusException(
              absl::InvalidArgumentError("rank must be specified"));
        }
        return ValueOrThrow(builder.Finalize());
      }),
      "Constructs a ChunkLayout.", py::arg("rank") = std::nullopt,
      py::arg("inner_order") = std::nullopt,
      py::arg("grid_origin") = std::nullopt,
      py::arg("write_chunk") = std::nullopt,
      py::arg("read_chunk") = std::nullopt,
      py::arg("codec_chunk") = std::nullopt);
  chunk_layout_cls.def("__repr__", [](const ChunkLayout& self) {
    return internal_python::PrettyPrintJsonAsPythonRepr(
        self.ToJson(IncludeDefaults{false}), "ChunkLayout(", ")");
  });
  chunk_layout_cls.def(
      "to_json",
      [](const ChunkLayout& self, bool include_defaults) {
        return self.ToJson(IncludeDefaults{include_defaults});
      },
      "Converts to the JSON representation.",
      py::arg("include_defaults") = false);
  chunk_layout_cls.def_property_readonly(
      "rank",
      [](const ChunkLayout& self) -> DimensionIndex { return self.rank(); },
      "Number of dimensions in the index space.");
  chunk_layout_cls.def_property_readonly(
      "ndim",
      [](const ChunkLayout& self) -> DimensionIndex { return self.rank(); },
      "Alias for :py:obj:`.rank`.");
  chunk_layout_cls.def_property_readonly(
      "inner_order",
      [](const ChunkLayout& self)
          -> std::optional<HomogeneousTuple<DimensionIndex>> {
        auto inner_order = self.inner_order();
        if (inner_order.empty()) return std::nullopt;
        return SpanToHomogeneousTuple<DimensionIndex>(inner_order);
      });
  chunk_layout_cls.def_property_readonly(
      "grid_origin",
      [](const ChunkLayout& self) -> HomogeneousTuple<Index> {
        return SpanToHomogeneousTuple<Index>(self.grid_origin());
      },
      "Grid origin");
  chunk_layout_cls.def_property_readonly(
      "write_chunk",
      [](const ChunkLayout& self) -> ChunkLayout::Grid {
        return ChunkLayout::Grid(self.write_chunk());
      },
      "Chunk grid for efficient writes.");
  chunk_layout_cls.def_property_readonly(
      "read_chunk",
      [](const ChunkLayout& self) -> ChunkLayout::Grid {
        return ChunkLayout::Grid(self.read_chunk());
      },
      "Chunk grid for efficient reads.");
  chunk_layout_cls.def_property_readonly(
      "codec_chunk",
      [](const ChunkLayout& self) -> ChunkLayout::Grid {
        return ChunkLayout::Grid(self.codec_chunk());
      },
      "Chunk grid used by the codec.");
  chunk_layout_cls.def_property_readonly(
      "write_chunk_template",
      [](const ChunkLayout& self) -> IndexDomain<> {
        return ValueOrThrow(
            GetChunkTemplateAsIndexDomain(self, ChunkLayout::Usage::kWrite));
      },
      "Chunk template for efficient writes.");
  chunk_layout_cls.def_property_readonly(
      "read_chunk_template",
      [](const ChunkLayout& self) -> IndexDomain<> {
        return ValueOrThrow(
            GetChunkTemplateAsIndexDomain(self, ChunkLayout::Usage::kRead));
      },
      "Chunk template for efficient reads.");
  chunk_layout_cls.def("__eq__",
                       [](const ChunkLayout& self, const ChunkLayout& other) {
                         return self == other;
                       });
}

}  // namespace internal_python
}  // namespace tensorstore

namespace pybind11 {
namespace detail {

bool type_caster<tensorstore::ChunkLayout::Usage>::load(handle src,
                                                        bool convert) {
  if (!PyUnicode_Check(src.ptr())) return false;
  Py_ssize_t size;
  const char* s = PyUnicode_AsUTF8AndSize(src.ptr(), &size);
  if (!s) {
    PyErr_Clear();
    return false;
  }
  value = tensorstore::internal_python::ValueOrThrow(
      tensorstore::ChunkLayout::ParseUsage(std::string_view(s, size)));
  return true;
}

handle type_caster<tensorstore::ChunkLayout::Usage>::cast(
    tensorstore::ChunkLayout::Usage usage, return_value_policy /* policy */,
    handle /* parent */) {
  return pybind11::cast(tensorstore::StrCat(usage)).release();
}

}  // namespace detail
}  // namespace pybind11
